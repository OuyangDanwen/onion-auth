import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.spec.SecretKeySpec;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;

public class Sender {
	
	// Socket communication
	private ObjectOutputStream toReceiver;
	private ObjectInputStream fromReceiver;

	// Personal keys
	private PrivateKey rsaPriKey;
	private PublicKey rsaPubKey;
	private PrivateKey dhPriKey;
	private PublicKey dhPubKey;
	// Received keys from the other peer
	private PublicKey receivedDHPubKey;
	private PublicKey receivedRSAPubKey;

	// Received data from the other peer
	private byte[] receivedMessage = new byte[1024];
	private int receivedMessageLength;
	private byte[] receivedSignature = new byte[128];
	private byte[] receivedHashedSecretKey;

	public static void main(String[] args) {
		Sender sender = new Sender();
		sender.run();
	}

	private void run() {
		try {
			int receiverPortNum = 9191;
			String receiverIPAddress = "127.0.0.1";
			Socket skt = new Socket(receiverIPAddress, receiverPortNum);
			toReceiver = new ObjectOutputStream(skt.getOutputStream());
			fromReceiver = new ObjectInputStream(skt.getInputStream());
			System.out.println("Sender: Connection established with receiver on port " + receiverPortNum);

			generateKeys();
			
			sendDHPublicKey();

			receiveMessageWithSignature();
			extractDataFromMessage();
			if (verifySignature()) {
				System.out.println("Sender: Signature is a match!");
				byte[] hashedSecretKey = hashSecretKey(generateSecretKey());
				if (compareSecretKeyHashes(hashedSecretKey, receivedHashedSecretKey)) {
					System.out.println("Sender: Hashes of secret key are a match!");
				} else {
					System.out.println("Sender: Hashes of secret key do not match");
				}
			} else {
				System.out.println("Sender: Signatures do not match");
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/*
	 * =============== HELPER METHODS ===============
	 */

	// Generates a pair of DH and RSA private and public keys
	private void generateKeys() throws Exception {
		// DH key pair
		KeyPairGenerator keyPairGenDh = KeyPairGenerator.getInstance("DH");
		keyPairGenDh.initialize(1024);
		KeyPair keyPairDh = keyPairGenDh.generateKeyPair();
		dhPriKey = keyPairDh.getPrivate();
		dhPubKey = keyPairDh.getPublic();

		// RSA key pair
		KeyPairGenerator keyPairGenRsa = KeyPairGenerator.getInstance("RSA");
		keyPairGenRsa.initialize(1024);
		KeyPair keyPairRsa = keyPairGenRsa.generateKeyPair();
		rsaPriKey = keyPairRsa.getPrivate();
		rsaPubKey = keyPairRsa.getPublic();

		System.out.println("Sender: Keys generated");
	}

	// Sends own DH public key to the other peer 
	private void sendDHPublicKey() throws Exception {
		toReceiver.writeObject(dhPubKey);
		toReceiver.flush();
	}

	// Receives the message and the signature from the other peer
	private void receiveMessageWithSignature() throws Exception {
		receivedMessageLength = fromReceiver.read(receivedMessage, 0, receivedMessage.length);
		System.out.println("Sender: receivedMessage.length = " + receivedMessageLength);
		System.out.println("Sender: receivedSignature.length = " + fromReceiver.read(receivedSignature, 0, receivedSignature.length));
	}

	// Extracts the following data from the message:
	// 1. DH public key of the other peer
	// 2. RSA public key of the other peer
	// 3. Hash value of the secret key generated by the other peer (this is returned)
	private void extractDataFromMessage() throws Exception {
		int a = dhPubKey.getEncoded().length; // used as reference for the length
		int b = rsaPubKey.getEncoded().length; // used as reference for the length

		// Get the DH public key
		byte[] receivedDHPubKeyEncoded = Arrays.copyOfRange(receivedMessage, 0, a);
		receivedDHPubKey = KeyFactory.getInstance("DH").generatePublic(new X509EncodedKeySpec(receivedDHPubKeyEncoded));
		System.out.println("Sender: receivedDHPubKey.length = " + receivedDHPubKey.getEncoded().length);

		// Get the RSA public key
		byte[] receivedRSAPubKeyEncoded = Arrays.copyOfRange(receivedMessage, a, a+b);
		receivedRSAPubKey = KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(receivedRSAPubKeyEncoded));
		System.out.println("Sender: receivedRSAPubKey.length = " + receivedRSAPubKey.getEncoded().length);

		// Get the hash value of the secret key
		receivedHashedSecretKey = Arrays.copyOfRange(receivedMessage, a+b, receivedMessageLength);
		System.out.println("Sender: receivedHashedSecretKey.length = " + receivedHashedSecretKey.length);
	}

	// Verifies the signature of the message with the RSA public key sent by the other peer
	private boolean verifySignature() throws Exception {
		System.out.println("Sender: Verifying signature");
		Signature sig = Signature.getInstance("SHA256withRSA");
		sig.initVerify(receivedRSAPubKey); 
		sig.update(receivedMessage);

		return sig.verify(receivedSignature);
	}

	// Generate a secret key using the other peer's public key and own private key
	private byte[] generateSecretKey() throws Exception {
		KeyAgreement keyAgreement = KeyAgreement.getInstance("DH");
		keyAgreement.init(dhPriKey);
		keyAgreement.doPhase(receivedDHPubKey, true);

		byte[] rawSecretKey = keyAgreement.generateSecret();
		byte[] secretKey = new byte[16]; // 128-bit key
		System.arraycopy(rawSecretKey, 0, secretKey, 0, secretKey.length); // convert to 128-bit key
		System.out.println("Sender: Secret key generated");

		return secretKey;
	}

	// Hashes the secret key using SHA-256 algorithm
	private byte[] hashSecretKey(byte[] secretKey) throws Exception {
		MessageDigest md = MessageDigest.getInstance("SHA-256");
		md.update(secretKey);
		System.out.println("Sender: Secret key hashed using SHA-256");
		return md.digest();
	}

	// Compares the values of the 2 secret key hashes 
	private boolean compareSecretKeyHashes(byte[] hashedSecretKey, byte[] receivedHashedSecretKey) {
		return Arrays.equals(hashedSecretKey, receivedHashedSecretKey);
	}
}